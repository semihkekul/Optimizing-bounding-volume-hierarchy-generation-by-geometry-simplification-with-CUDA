#pragma once

#include "gpuWrapper.cuh"
#include "GameObject.h"

cudaEvent_t start, stop;
//static float elapsedTime = 0;

#define MEASURE_START									\
			CUDAErrorCheck(cudaEventCreate(&start));	\
			CUDAErrorCheck(cudaEventCreate(&stop));		\
			CUDAErrorCheck(cudaEventRecord(start, 0));

#define MEASURE_END(funcName)                                          \
			CUDAErrorCheck(cudaEventRecord(stop, 0));				   \
			CUDAErrorCheck(cudaEventSynchronize(stop));				   \
			CUDAErrorCheck(cudaEventElapsedTime(&elapsedTime, start, stop));  \
			std::cout << funcName <<" : "<<elapsedTime << " ms"<<std::endl;


void _printMatrix(const Matrix& mtx)
{
	printf("%f  %f  %f %f \n%f  %f  %f %f \n%f  %f  %f %f \n%f  %f  %f %f \n\n",
		mtx.row1.x,
		mtx.row1.y,
		mtx.row1.z,
		mtx.row1.w,
		mtx.row2.x,
		mtx.row2.y,
		mtx.row2.z,
		mtx.row2.w,
		mtx.row3.x,
		mtx.row3.y,
		mtx.row3.z,
		mtx.row3.w,
		mtx.row4.x,
		mtx.row4.y,
		mtx.row4.z,
		mtx.row4.w);
}
void GpuAssert(cudaError_t code, const char *file, int line)
{
	if (code != cudaSuccess)
	{
		fprintf(stderr, "\n\nGPUassert: %s %s %d\n\n", cudaGetErrorString(code), file, line);
		cudaDeviceReset();
		system("pause");
	}
}

void initCUDA()
{
	PrintFunction;
	cudaDeviceProp deviceprop;
	CUDAErrorCheck(cudaGetDeviceProperties(&deviceprop, 0));
	printf("Device name: %s\n", deviceprop.name);
	printf("Compute capability:%d.%d\n", deviceprop.major, deviceprop.minor);
	printf("Memory Clock Rate (KHz): %d\n",
		deviceprop.memoryClockRate);
	printf("Memory Bus Width (bits): %d\n",
		deviceprop.memoryBusWidth);
	printf("Peak Memory Bandwidth (GB/s): %f\n",
		2.0*deviceprop.memoryClockRate*(deviceprop.memoryBusWidth / 8) / 1.0e6);

	printf("  Shared memory available per block in KB : %d\n",
		deviceprop.sharedMemPerBlock / 1024);

	std::cout << "Global memory available on device in MB: " << deviceprop.totalGlobalMem / 1024 / 1024 << std::endl;

	printf(" Maximum size of each dimension of a block: %d %d %d\n", deviceprop.maxThreadsDim[0], deviceprop.maxThreadsDim[1], deviceprop.maxThreadsDim[2]);
	printf(" Maximum size of each dimension of a grid: %d %d %d\n", deviceprop.maxGridSize[0], deviceprop.maxGridSize[1], deviceprop.maxGridSize[2]);

}

typedef std::string String;

void printVertex(const Vertex& v)
{
	printf("%f  %f  %f \n",
		v.x,
		v.y,
		v.z);
}


//@brief the first occurence of each morton code is flagged and the occurence list is visited with an inclusive scan to get a mapping dev_MortonSortedToClMapping.
// A compact list is also generated by thrust::unique_by_key from sorted morton codes to Cl
//@param dev_sortedMortonCodes; input; sorted morton codes
//@param vertexCount; input; 
//@param dev_MortonSortedToClMapping; output; sorted morton code index  -> Cl index ; 
// nth mortonCode is mapped to dev_MortonSortedToClMapping[n]
//@param dev_indicesOfCl; output; compact sorted morton codes indices     dev_sortedMortonCodes[dev_indicesOfCl[n]] -> first occurence of morton code

/*gSimplificationParameters.dev_sortedMortonCodes,
		gSimplificationParameters.vertexCount,
		gSimplificationParameters.dev_MortonSortedToClMapping,
		gSimplificationParameters.dev_indicesOfMortonCodes = > uint* dev_indicesOfCl
		*/


void removeDuplicatesWithCuda()
{
	PrintFunction;
	int threadsPerBlock = 256;
	int numBlocks = (gSimplificationParameters.vertexCount + threadsPerBlock - 1) / threadsPerBlock;
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	MarkFirstOccurencesKernel <<< numBlocks, threadsPerBlock >>> (gSimplificationParameters.dev_MortonCodes, gSimplificationParameters.vertexCount, gSimplificationParameters.dev_MortonSortedToClMapping);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	
	//uint* MortonSortedToClMapping = new uint[gSimplificationParameters.vertexCount];
	//CUDAErrorCheck(cudaMemcpy(MortonSortedToClMapping, gSimplificationParameters.dev_MortonSortedToClMapping, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	//printArray(MortonSortedToClMapping, gSimplificationParameters.vertexCount, "First Occurences of Morton");
	
	
	try
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::inclusive_scan(thrust::device,
			gSimplificationParameters.dev_MortonSortedToClMapping,
			gSimplificationParameters.dev_MortonSortedToClMapping + gSimplificationParameters.vertexCount,
			gSimplificationParameters.dev_MortonSortedToClMapping);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	}
	CUDAErrorCheck(cudaGetLastError());

/*
	uint* MortonSortedToClMapping = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(MortonSortedToClMapping, gSimplificationParameters.dev_MortonSortedToClMapping, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(MortonSortedToClMapping, gSimplificationParameters.vertexCount, "MortonSorted To ClMapping");
	 */

	uint* dev_indicesOfCl = gSimplificationParameters.dev_indicesOfMortonCodes;   // reusing memory
	
	numBlocks = (gSimplificationParameters.vertexCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	setIncreasingIdKernel << <numBlocks, threadsPerBlock >> > (dev_indicesOfCl, gSimplificationParameters.vertexCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
	
	/*
	* uint* indicesOfCl = new uint[gSimplificationParameters.vertexCount];
	* CUDAErrorCheck(cudaMemcpy(indicesOfCl, dev_indicesOfCl, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	* printArray(indicesOfCl, gSimplificationParameters.vertexCount, "MortonSorted To ClMapping");
	*/
     
	thrust::pair<uint*, uint*> new_end;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	try
	{
		new_end = thrust::unique_by_key(thrust::device,
			gSimplificationParameters.dev_MortonCodes,
			gSimplificationParameters.dev_MortonCodes + gSimplificationParameters.vertexCount,
			dev_indicesOfCl
		);
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	//////////////
	///// morton codes are now compact
	/////////////
	gSimplificationParameters.clCount = new_end.first - gSimplificationParameters.dev_MortonCodes;
	
	 
	//printf("Cl count is %d\n", gSimplificationParameters.clCount);
	//uint* indicesOfCompactCl = new uint[gSimplificationParameters.clCount];
	//CUDAErrorCheck(cudaMemcpy(indicesOfCompactCl, dev_indicesOfCl, gSimplificationParameters.clCount * sizeof(uint), cudaMemcpyDeviceToHost));
	//printArray(indicesOfCompactCl, gSimplificationParameters.clCount, "indices of CL");
	
}

//@brief sort the morton codes and store the mapping from vertex index to morton index
//@param dev_unsortedMortonCodes input and ouput; the unsorted morton codes -> sorted morton codes
//@param dev_unsortedIds input and output the index of the morton codes; (0..vertexCount) -> (sorted_idx0..sorted_idxVertexCount)
//@param dev_VertexToMortonMapping output ; dev_VertexToMortonMapping[n] is the morton index of the morton code generated from nth vertex
//gSimplificationParameters.dev_sortedMortonCodes, gSimplificationParameters.dev_ids, gSimplificationParameters.dev_VertexToMortonMapping, gSimplificationParameters.vertexCount
void sortMortonCodesWithCuda()
{
	
	PrintFunction;

	int threadsPerBlock = 256;
	int numBlocks = (gSimplificationParameters.vertexCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	setIncreasingIdKernel << <numBlocks, threadsPerBlock >> > (gSimplificationParameters.dev_MortonToVertexMapping, gSimplificationParameters.vertexCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	thrust::device_ptr<uint> dev_thrustUnsortedMortonCodes = thrust::device_pointer_cast(gSimplificationParameters.dev_MortonCodes);
	thrust::device_ptr<uint> dev_thrustUnsortedIndices = thrust::device_pointer_cast(gSimplificationParameters.dev_MortonToVertexMapping);


	try
	{

		///////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::sort_by_key(dev_thrustUnsortedMortonCodes, dev_thrustUnsortedMortonCodes + gSimplificationParameters.vertexCount, dev_thrustUnsortedIndices);
		///////////////////////////////////////////////////////////////////////////////////////////////////
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	}

	CUDAErrorCheck(cudaGetLastError());

	
	/*
	uint* mortonCodes = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(mortonCodes, gSimplificationParameters.dev_MortonCodes, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(mortonCodes, gSimplificationParameters.vertexCount, "mortonCodes Sorted");
	
	uint* mortonToVertexMapping = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(mortonToVertexMapping, gSimplificationParameters.dev_MortonToVertexMapping, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(mortonToVertexMapping, gSimplificationParameters.vertexCount, "mortonToVertexMapping");
	*/
	numBlocks = (gSimplificationParameters.vertexCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	VertexToMortonMapGenerateKernel <<<numBlocks, threadsPerBlock >>> (gSimplificationParameters.dev_VertexToMortonMapping, gSimplificationParameters.dev_MortonToVertexMapping, gSimplificationParameters.vertexCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
	
	/*
	 uint* VertexToMortonMapping = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(VertexToMortonMapping, gSimplificationParameters.dev_VertexToMortonMapping, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(VertexToMortonMapping, gSimplificationParameters.vertexCount, "VertexToMortonMapping");
	
	
	uint* MortonToVertex = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(MortonToVertex, gSimplificationParameters.dev_MortonToVertexMapping, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(MortonToVertex, gSimplificationParameters.vertexCount, "MortonToVertex");
	*/
}


//@brief calls device kernel to calculate a 30-bit Morton code for the
void createMortonCodesWithCuda(stScene scene)
{

	PrintFunction;

	int threadsPerBlock = 256;
	int numBlocks = (gSimplificationParameters.vertexCount + threadsPerBlock - 1) / threadsPerBlock;

	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	mortonKernel <<<numBlocks, threadsPerBlock >>>(gSimplificationParameters.dev_vertices, gSimplificationParameters.vertexCount, gSimplificationParameters.dev_MortonCodes, scene);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	/*
	uint* mortonCodes = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(mortonCodes, gSimplificationParameters.dev_MortonCodes, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(mortonCodes, gSimplificationParameters.vertexCount, "mortonCodes");
	*/
}

//@brief
void mortonIntegralsWithCuda()
{
	PrintFunction;
	try
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::inclusive_scan(thrust::device, gSimplificationParameters.dev_Ql, 
			gSimplificationParameters.dev_Ql + gSimplificationParameters.clCount, 
			gSimplificationParameters.dev_QScan, MatrixSum());
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::inclusive_scan(thrust::device, gSimplificationParameters.dev_totalSumVertexOFCl, 
			gSimplificationParameters.dev_totalSumVertexOFCl + gSimplificationParameters.clCount, 
			gSimplificationParameters.dev_TotalVertexSumScan, VertexSum());
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::inclusive_scan(thrust::device, gSimplificationParameters.dev_vertexCountOfCl, 
			gSimplificationParameters.dev_vertexCountOfCl + gSimplificationParameters.clCount, 
			gSimplificationParameters.dev_vertexCountScan);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	}

	CUDAErrorCheck(cudaGetLastError());
	
	//Vertex* totalVertices = new Vertex[gSimplificationParameters.clCount];
	//CUDAErrorCheck(cudaMemcpy(totalVertices, gSimplificationParameters.dev_totalSumVertexOFCl, 
	//	gSimplificationParameters.clCount * sizeof(Vertex), cudaMemcpyDeviceToHost));
	//for(int i = 0; i <gSimplificationParameters.clCount;++i)
	//printVertex (totalVertices[i]);
	

	//Matrix* qScan = new Matrix[gSimplificationParameters.clCount];
	//CUDAErrorCheck(cudaMemcpy(qScan, gSimplificationParameters.dev_QScan, gSimplificationParameters.clCount * sizeof(Matrix), cudaMemcpyDeviceToHost));
	//for (int i = 0; i < gSimplificationParameters.clCount; ++i)
	//	_printMatrix(qScan[i]);

}



//@brief

void QuadricsprocessWithCuda()
{
	PrintFunction;
	int threadsPerBlock = 256;
	int numBlocks = (gSimplificationParameters.faceCount + threadsPerBlock - 1) / threadsPerBlock;

	// Compute the face quadric Qt of each triangle t of mesh M
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CalculateFaceQuadricKernel <<<numBlocks, threadsPerBlock >>>(gSimplificationParameters.dev_vertices,
		gSimplificationParameters.dev_quadricsOfFaces, //Qt
		gSimplificationParameters.dev_gpuFaces, // t
		gSimplificationParameters.faceCount);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	//Matrix* temp_Matrices = new Matrix[gSimplificationParameters.faceCount];
	//CUDAErrorCheck(cudaMemcpy(temp_Matrices, gSimplificationParameters.dev_quadricsOfFaces, gSimplificationParameters.faceCount * sizeof(Matrix), cudaMemcpyDeviceToHost));
	//for (int i = 0; i < gSimplificationParameters.faceCount; ++i)
	//	printf("%d \n%f  %f  %f %f \n%f  %f  %f %f \n%f  %f  %f %f \n%f  %f  %f %f \n\n",i,
	//		temp_Matrices[i].row1.x,
	//		temp_Matrices[i].row1.y,
	//		temp_Matrices[i].row1.z,
	//		temp_Matrices[i].row1.w,
	//		temp_Matrices[i].row2.x,
	//		temp_Matrices[i].row2.y,
	//		temp_Matrices[i].row2.z,
	//		temp_Matrices[i].row2.w,
	//		temp_Matrices[i].row3.x,
	//		temp_Matrices[i].row3.y,
	//		temp_Matrices[i].row3.z,
	//		temp_Matrices[i].row3.w,
	//		temp_Matrices[i].row4.x,
	//		temp_Matrices[i].row4.y,
	//		temp_Matrices[i].row4.z,
	//		temp_Matrices[i].row4.w);
		/*
	uint* temp = new uint[gSimplificationParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(temp, gSimplificationParameters.dev_MortonSortedToClMapping, gSimplificationParameters.vertexCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(temp, gSimplificationParameters.vertexCount, "dev_MortonSortedToClMapping");
	
	GPUFace* temp = new GPUFace[gSimplificationParameters.faceCount];
	CUDAErrorCheck(cudaMemcpy(temp, gSimplificationParameters.dev_gpuFaces, gSimplificationParameters.faceCount * sizeof(GPUFace), cudaMemcpyDeviceToHost));
	for (int f = 0; f  < gSimplificationParameters.faceCount; ++f)
	{
		printf("%d %d %d\n", temp[f].vertexIndices.first, temp[f].vertexIndices.second, temp[f].vertexIndices.third);
	}
		*/

	numBlocks = (gSimplificationParameters.faceCount + threadsPerBlock - 1) / threadsPerBlock;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	SumLeafQuadricKernel <<<numBlocks, threadsPerBlock >>>(gSimplificationParameters.dev_Ql,
		gSimplificationParameters.dev_totalSumVertexOFCl,
		gSimplificationParameters.dev_vertexCountOfCl,
		gSimplificationParameters.dev_vertices,
		gSimplificationParameters.dev_MortonSortedToClMapping,
		gSimplificationParameters.dev_VertexToMortonMapping,
		gSimplificationParameters.dev_quadricsOfFaces,
		gSimplificationParameters.dev_gpuFaces,
		gSimplificationParameters.faceCount);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

		 
	//Matrix* temp_Matrices = new Matrix[gSimplificationParameters.clCount];
	// CUDAErrorCheck(cudaMemcpy(temp_Matrices, gSimplificationParameters.dev_Ql, gSimplificationParameters.clCount * sizeof(Matrix), cudaMemcpyDeviceToHost));
	//for (int i = 0; i < gSimplificationParameters.clCount; ++i)
	//	_printMatrix( temp_Matrices[i]);

	
	 //uint* vertexCountScan = new uint[gSimplificationParameters.clCount];
	 //CUDAErrorCheck(cudaMemcpy(vertexCountScan, gSimplificationParameters.dev_vertexCountOfCl, gSimplificationParameters.clCount * sizeof(uint), cudaMemcpyDeviceToHost));
	 //printArray(vertexCountScan, gSimplificationParameters.clCount, "vertexCountScan");

}

void ParallelTreeConstructionWithCuda()
{
	PrintFunction;
	int threadsPerBlock = 256;
	int numBlocks = (gSimplificationParameters.clCount + threadsPerBlock - 1) / threadsPerBlock;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CalculateRepresentativePointsOfLeavesKernel << <numBlocks, threadsPerBlock >> > (gSimplificationParameters.dev_Ql,
		gSimplificationParameters.dev_totalSumVertexOFCl,
		gSimplificationParameters.dev_vertexCountOfCl,
		gSimplificationParameters.dev_leafNodes, 
		gSimplificationParameters.clCount);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	

	uint* Cl = gSimplificationParameters.dev_MortonCodes;
	numBlocks = (gSimplificationParameters.clCount + threadsPerBlock - 1) / threadsPerBlock;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	generateKdTreeKernel <<<numBlocks, threadsPerBlock >>> (gSimplificationParameters.dev_QScan, 
		gSimplificationParameters.dev_TotalVertexSumScan,
		gSimplificationParameters.dev_vertexCountScan,
		Cl,
		gSimplificationParameters.clCount,
		gSimplificationParameters.dev_leafNodes,
		gSimplificationParameters.dev_internalNodes);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());


	//dumpPaths << <numBlocks, threadsPerBlock >> >(gSimplificationParameters.dev_internalNodes, gSimplificationParameters.clCount -1);
	//CUDAErrorCheck(cudaGetLastError());


	//GpuNode* temp = new GpuNode[gSimplificationParameters.clCount];
	//CUDAErrorCheck(cudaMemcpy(temp, gSimplificationParameters.dev_internalNodes, (gSimplificationParameters.clCount - 1)* sizeof(GpuNode), cudaMemcpyDeviceToHost));
	//for(uint i = 0; i < gSimplificationParameters.clCount- 1; ++i)
	//{
	//	printf("%f\n", temp[i].En);
	//}


}

void AdaptiveSamplingAndTriangleMarking()
{
	PrintFunction;

	int threadsPerBlock = 256;
	int numBlocks = (gSimplificationParameters.clCount + threadsPerBlock - 1) / threadsPerBlock;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	treeTraverselKernel <<<numBlocks, threadsPerBlock >>> (gSimplificationParameters.dev_P, 
		gSimplificationParameters.clCount, 
		gSimplificationParameters.dev_internalNodes, 
		gSimplificationParameters.dev_leafNodes,
		gSimplificationParameters.theta,
		gSimplificationParameters.eyePosition,
		gSimplificationParameters.distanceRange);

	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
	
	/* uint2* P = new uint2[gSimplificationParameters.clCount];
	 CUDAErrorCheck(cudaMemcpy(P, gSimplificationParameters.dev_P, gSimplificationParameters.clCount * sizeof(uint2), cudaMemcpyDeviceToHost));
	 for(int i = 0; i < gSimplificationParameters.clCount; ++i)
	 {
		 printf("isLeaf{%d}  idx{%d}\n", P[i].x, P[i].y);
	 }*/

	numBlocks = (gSimplificationParameters.clCount + threadsPerBlock - 1) / threadsPerBlock;
		
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	PToVPrimeKernel << < numBlocks, threadsPerBlock >> > (gSimplificationParameters.clCount, gSimplificationParameters.dev_P, gSimplificationParameters.dev_PToVPrime);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	/*
	uint* PToVPrim = new uint[gSimplificationParameters.clCount];
	CUDAErrorCheck(cudaMemcpy(PToVPrim, gSimplificationParameters.dev_PToVPrime, gSimplificationParameters.clCount * sizeof(uint), cudaMemcpyDeviceToHost));
	printArray(PToVPrim, gSimplificationParameters.clCount, "PToVPrim");*/
	
	gBVHParameters.vertexCount = gSimplificationParameters.clCount;

		/* 
		 * 
	numBlocks = (gSimplificationParameters.clCount + threadsPerBlock - 1) / threadsPerBlock;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	doesExistsKernel << < numBlocks, threadsPerBlock >> > (gSimplificationParameters.dev_P, 
		gSimplificationParameters.clCount, 
		gSimplificationParameters.dev_PToVPrime);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	
			//
			//uint* vExists = new uint[gSimplificationParameters.clCount];
			//CUDAErrorCheck(cudaMemcpy(vExists, gSimplificationParameters.dev_PToVPrime, gSimplificationParameters.clCount * sizeof(uint), cudaMemcpyDeviceToHost));
			//printArray(vExists, gSimplificationParameters.clCount, "vExists");
			//

	 try
	 {
		 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		 thrust::exclusive_scan(thrust::device,
			gSimplificationParameters.dev_PToVPrime,
			gSimplificationParameters.dev_PToVPrime + gSimplificationParameters.clCount,
			gSimplificationParameters.dev_PToVPrime);
		 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	 }
	 catch (thrust::system_error &e)
	 {
		 std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	 }
	 CUDAErrorCheck(cudaGetLastError());
	
	 CUDAErrorCheck(cudaMemcpy(&gBVHParameters.vertexCount, &gSimplificationParameters.dev_PToVPrime[gSimplificationParameters.clCount-1],  sizeof(uint), cudaMemcpyDeviceToHost));
	 gBVHParameters.vertexCount++;
	*/
	 //uint* PtoV_ = new uint[gSimplificationParameters.clCount];
	 //CUDAErrorCheck(cudaMemcpy(PtoV_, gSimplificationParameters.dev_PToVPrime, gSimplificationParameters.clCount * sizeof(uint), cudaMemcpyDeviceToHost));
	 //printArray(PtoV_, gBVHParameters.vertexCount, "P TO V prime remesh");


	numBlocks = (gSimplificationParameters.faceCount + threadsPerBlock - 1) / threadsPerBlock;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	markTrianglesKernel <<< numBlocks, threadsPerBlock >>> (
		gSimplificationParameters.dev_gpuFaces,
		gSimplificationParameters.faceCount,
		gSimplificationParameters.dev_P,
		gSimplificationParameters.dev_MarkedFaceIndices,
		gSimplificationParameters.dev_MortonSortedToClMapping,
		gSimplificationParameters.dev_VertexToMortonMapping,
		gSimplificationParameters.dev_MortonToVertexMapping,
		gSimplificationParameters.dev_PToVPrime
		);  // for each triangle
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	try
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::inclusive_scan(thrust::device,
			gSimplificationParameters.dev_MarkedFaceIndices,
			gSimplificationParameters.dev_MarkedFaceIndices + gSimplificationParameters.faceCount,
			gSimplificationParameters.dev_MarkedFaceIndices);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	}
	CUDAErrorCheck(cudaGetLastError());

	//uint* temp = new uint[gSimplificationParameters.faceCount];
	//CUDAErrorCheck(cudaMemcpy(temp, gSimplificationParameters.dev_MarkedFaceIndices, (gSimplificationParameters.faceCount)* sizeof(uint), cudaMemcpyDeviceToHost));
	//for(uint i = 0; i < gSimplificationParameters.faceCount; ++i)
	//{
	//	printf("%d\n", temp[i]);
	//}
	numBlocks = (gSimplificationParameters.faceCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	setIncreasingIdKernel << <numBlocks, threadsPerBlock >> > (gSimplificationParameters.dev_IndicesOfFacesPrime, gSimplificationParameters.faceCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());


	thrust::pair<uint*, uint*> new_end;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	try
	{
		new_end = thrust::unique_by_key(thrust::device,
			gSimplificationParameters.dev_MarkedFaceIndices,
			gSimplificationParameters.dev_MarkedFaceIndices + gSimplificationParameters.faceCount,
			gSimplificationParameters.dev_IndicesOfFacesPrime
		);
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
	

	gBVHParameters.primitiveCount = new_end.first - gSimplificationParameters.dev_MarkedFaceIndices;

	
	 //printf("primitive count is %d\n", gBVHParameters.primitiveCount);
	 //uint* primitiveIndices = new uint[gBVHParameters.primitiveCount];
	 //CUDAErrorCheck(cudaMemcpy(primitiveIndices, gSimplificationParameters.dev_IndicesOfFacesPrime, gBVHParameters.primitiveCount * sizeof(uint), cudaMemcpyDeviceToHost));
	 //printArray(primitiveIndices, gBVHParameters.primitiveCount, "indices of primitives");
	 //delete[] primitiveIndices;
	

}



void CreatePrimitiveMortonsByCuda(stScene scene)
{
	PrintFunction;

	int threadsPerBlock = 256;
	int numBlocks = (gBVHParameters.primitiveCount + threadsPerBlock - 1) / threadsPerBlock;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	calculateFaceCenterKernel <<<numBlocks, threadsPerBlock >>> (gBVHParameters.dev_primitives, 
		gBVHParameters.dev_primitiveCenters, 
		gBVHParameters.primitiveCount,
		gBVHParameters.dev_Vertices);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	//Vertex* vertices = new Vertex[gBVHParameters.vertexCount];
	//CUDAErrorCheck(cudaMemcpy(vertices, gBVHParameters.dev_Vertices, gBVHParameters.vertexCount * sizeof(Vertex), cudaMemcpyDeviceToHost));
	//for (unsigned int i = 0; i < gBVHParameters.vertexCount; ++i)
	//	printVertex(vertices[i]);
	//delete[] vertices;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	mortonKernel <<<numBlocks, threadsPerBlock >>>(gBVHParameters.dev_primitiveCenters, gBVHParameters.primitiveCount, gBVHParameters.dev_MortonCodes, scene);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
	

}

//parameters are input and output at the same time
//dev_primitiveMortonCodes, dev_unsortedPrimitiveIDs, primitiveCount
//uint* dev_unsortedMortonCodes, uint* dev_unsortedPrimitiveIDs, uint primitiveCount
void sortPrimitiveMortonCodesWithCuda()
{
	PrintFunction;

	int threadsPerBlock = 256;
	int numBlocks = (gBVHParameters.primitiveCount + threadsPerBlock - 1) / threadsPerBlock;

	///////////////////////////////////////////////////////////////////////////////////////////////////
	setIncreasingIdKernel <<<numBlocks, threadsPerBlock >>> (gBVHParameters.dev_ids, gBVHParameters.primitiveCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	thrust::device_ptr<uint> dev_thrustUnsortedMortonCodes = thrust::device_pointer_cast(gBVHParameters.dev_MortonCodes);
	thrust::device_ptr<uint> dev_thrustUnsortedPrimitiveIDs = thrust::device_pointer_cast(gBVHParameters.dev_ids);
	try
	{
		///////////////////////////////////////////////////////////////////////////////////////////////////
		thrust::sort_by_key(thrust::device, dev_thrustUnsortedMortonCodes, dev_thrustUnsortedMortonCodes + gBVHParameters.primitiveCount, dev_thrustUnsortedPrimitiveIDs);
		///////////////////////////////////////////////////////////////////////////////////////////////////
	}
	catch (thrust::system_error &e)
	{
		std::cout << __FUNCTION__ << "::" << __LINE__ << std::endl << e.what() << std::endl;	
	}

	CUDAErrorCheck(cudaGetLastError());

}
//dev_leafNodes, dev_aabbs, primitiveCount
//GpuNode* dev_leafNodes, stAABB* dev_aabbs,  uint primitiveCount
void generateAABBsWithCuda()
{
	PrintFunction;
	int threadsPerBlock = 256;
	int numBlocks = (gBVHParameters.primitiveCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	generateAABBKernel << < numBlocks, threadsPerBlock >> >(gBVHParameters.dev_leafNodes, gBVHParameters.dev_Vertices, gBVHParameters.dev_primitives, gBVHParameters.primitiveCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
}


void calculateBoundingBoxesWithCuda()
{
	PrintFunction;
	int threadsPerBlock = 256;
	int numBlocks = (gBVHParameters.primitiveCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	boundingBoxCalculationKernel << < numBlocks, threadsPerBlock >> >(gBVHParameters.dev_leafNodes, gBVHParameters.primitiveCount);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
}

//dev_primitiveMortonCodes, dev_leafNodes, dev_internalNodes, primitiveCount
/*unsigned int* dev_sortedMortonCodes,
	GpuNode* dev_leafNodeBuffer,
	GpuNode* dev_internalNodeBuffer,
	uint primitiveCount
 */
void generateHierarchyWithCuda()
{
	
	PrintFunction;

	int threadsPerBlock = 256;
	int numBlocks = (gBVHParameters.primitiveCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////
	generateHierarchyKernel << < numBlocks, threadsPerBlock >> >(gBVHParameters.dev_MortonCodes, gBVHParameters.dev_leafNodes, gBVHParameters.dev_internalNodes, gBVHParameters.primitiveCount);
	///////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());

	
}

void Remeshing()
{
	PrintFunction;
	int threadsPerBlock = 256;
	int numBlocks = (gBVHParameters.primitiveCount + threadsPerBlock - 1) / threadsPerBlock;

	///////////////////////////////////////////////////////////////////////////////////////////////////
	remeshKernel << <numBlocks, threadsPerBlock >> > (gBVHParameters.dev_primitives, 
		gSimplificationParameters.dev_gpuFaces, 
		gSimplificationParameters.dev_IndicesOfFacesPrime,
		gBVHParameters.primitiveCount,
		gSimplificationParameters.dev_VertexToMortonMapping,
		gSimplificationParameters.dev_MortonSortedToClMapping,
		gSimplificationParameters.dev_P,
		gSimplificationParameters.dev_PToVPrime);

	///////////////////////////////////////////////////////////////////////////////////////////////////
	
	CUDAErrorCheck(cudaGetLastError());

	//GPUFace* gpufaces = new GPUFace[gBVHParameters.primitiveCount];
	//CUDAErrorCheck(cudaMemcpy(gpufaces, gBVHParameters.dev_primitives, gBVHParameters.primitiveCount * sizeof(GPUFace), cudaMemcpyDeviceToHost));
	//for (uint i = 0; i < gBVHParameters.primitiveCount; ++i)
	//{
	//	printf("%d %d %d\n", gpufaces[i].vertexIndices.first, gpufaces[i].vertexIndices.second, gpufaces[i].vertexIndices.third);
	//}

	//Vertex* vertices = new Vertex[gSimplificationParameters.vertexCount];
	//CUDAErrorCheck(cudaMemcpy(vertices, gSimplificationParameters.dev_vertices, gSimplificationParameters.vertexCount * sizeof(Vertex), cudaMemcpyDeviceToHost));
	//for (unsigned int i = 0; i < gSimplificationParameters.vertexCount; ++i)
	//	printVertex(vertices[i]);
	//delete[] vertices;
	
	//GpuNode* internalNodes = new GpuNode[gSimplificationParameters.clCount -1 ];
	//CUDAErrorCheck(cudaMemcpy(internalNodes, gSimplificationParameters.dev_internalNodes, (gSimplificationParameters.clCount - 1)* sizeof(GpuNode), cudaMemcpyDeviceToHost));
	//GpuNode* leafNodes = new GpuNode[gSimplificationParameters.clCount];
	//CUDAErrorCheck(cudaMemcpy(leafNodes, gSimplificationParameters.dev_leafNodes, gSimplificationParameters.clCount * sizeof(GpuNode), cudaMemcpyDeviceToHost));
	//for (unsigned int i = 0; i < gSimplificationParameters.clCount - 1 ; ++i)
	//	printVertex(internalNodes[i].xn);
	//printf(" === leafNodex === \n");
	//for (unsigned int i = 0; i < gSimplificationParameters.clCount; ++i)
	//	printVertex(leafNodes[i].xn);

	numBlocks = (gSimplificationParameters.clCount + threadsPerBlock - 1) / threadsPerBlock;
	///////////////////////////////////////////////////////////////////////////////////////////////////
	VtoVPrimeKernel << <numBlocks, threadsPerBlock >> > (gBVHParameters.dev_Vertices,
		gSimplificationParameters.dev_leafNodes,
		gSimplificationParameters.dev_internalNodes,
		gSimplificationParameters.clCount,
		gSimplificationParameters.dev_MortonToVertexMapping,
		gSimplificationParameters.dev_P,
		gSimplificationParameters.dev_PToVPrime);
	///////////////////////////////////////////////////////////////////////////////////////////////////
	CUDAErrorCheck(cudaGetLastError());
	/*Vertex* vertices = new Vertex[gBVHParameters.vertexCount];
	CUDAErrorCheck(cudaMemcpy(vertices, gBVHParameters.dev_Vertices, gBVHParameters.vertexCount * sizeof(Vertex), cudaMemcpyDeviceToHost));
	for (unsigned int i = 0; i < gBVHParameters.vertexCount; ++i)
		printVertex(vertices[i]);
	delete[] vertices;*/

}

float distance(const Vertex u, const Vertex v)
{
	Vertex k = make_float3(u.x - v.x, u.y - v.y, u.z - v.z);

	return sqrtf(powf(k.x, 2) + powf(k.y, 2) + powf(k.z, 2));
}

void cudaMain(std::vector<Vertex>& vertices,
	stScene& scene,
	std::vector<Face>& faces,
	stParameters& params)
{
	PrintFunction;


	gSimplificationParameters.vertexCount = vertices.size();
	gSimplificationParameters.faceCount = faces.size();
	gSimplificationParameters.faces = new GPUFace[gSimplificationParameters.faceCount];
	for (uint i = 0; i < gSimplificationParameters.faceCount; ++i)
	{
		gSimplificationParameters.faces[i].vertexIndices.first = faces[i].vertexIndices[0];
		gSimplificationParameters.faces[i].vertexIndices.second = faces[i].vertexIndices[1];
		gSimplificationParameters.faces[i].vertexIndices.third = faces[i].vertexIndices[2];
	}

	// Allocate GPU buffers
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_MortonCodes, gSimplificationParameters.vertexCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_vertices, gSimplificationParameters.vertexCount * sizeof(Vertex)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_gpuFaces, gSimplificationParameters.faceCount * sizeof(GPUFace)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_MortonToVertexMapping, gSimplificationParameters.vertexCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_VertexToMortonMapping, gSimplificationParameters.vertexCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_quadricsOfFaces, gSimplificationParameters.faceCount * sizeof(Matrix)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_MortonSortedToClMapping, gSimplificationParameters.vertexCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_indicesOfMortonCodes, gSimplificationParameters.vertexCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_Ql, gSimplificationParameters.vertexCount * sizeof(Matrix)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_QScan, gSimplificationParameters.vertexCount * sizeof(Matrix)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_TotalVertexSumScan, gSimplificationParameters.vertexCount * sizeof(Vertex)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_vertexCountScan, gSimplificationParameters.vertexCount * sizeof(uint)));

	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_totalSumVertexOFCl, gSimplificationParameters.vertexCount * sizeof(Vertex)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_vertexCountOfCl, gSimplificationParameters.vertexCount * sizeof(uint)));


	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_IndicesOfFacesPrime, gSimplificationParameters.faceCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_MarkedFaceIndices, gSimplificationParameters.faceCount * sizeof(uint)));

	CUDAErrorCheck(cudaMemset(gSimplificationParameters.dev_Ql, 0x0, gSimplificationParameters.vertexCount * sizeof(Matrix)));
	CUDAErrorCheck(cudaMemset(gSimplificationParameters.dev_totalSumVertexOFCl, 0x0, gSimplificationParameters.vertexCount * sizeof(Vertex)));
	CUDAErrorCheck(cudaMemset(gSimplificationParameters.dev_vertexCountOfCl, 0x0, gSimplificationParameters.vertexCount * sizeof(uint)));
	
	gSimplificationParameters.theta = params.theta;
	gSimplificationParameters.eyePosition = params.eyePosition;
	float minDistance = min(distance(params.eyePosition, scene.min), distance(params.eyePosition, scene.max));
	gSimplificationParameters.distanceRange = distance(scene.max, scene.min) + minDistance;


	CUDAErrorCheck(cudaMemcpy(gSimplificationParameters.dev_gpuFaces, gSimplificationParameters.faces, gSimplificationParameters.faceCount * sizeof(GPUFace), cudaMemcpyHostToDevice));

	CUDAErrorCheck(cudaMemcpy(gSimplificationParameters.dev_vertices, vertices.data(), gSimplificationParameters.vertexCount * sizeof(Vertex), cudaMemcpyHostToDevice));

	createMortonCodesWithCuda(scene);  // V -> MortonCodes


	sortMortonCodesWithCuda(); // after this point dev_sortedMortonCodes are really sort
	
	// dev_Cl is not allocated yet for the sake of algorihtm
	removeDuplicatesWithCuda();  // V -> Morton-> Cl

	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_leafNodes, gSimplificationParameters.clCount * sizeof(GpuNode)));
	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_internalNodes, (gSimplificationParameters.clCount - 1) * sizeof(GpuNode)));

	QuadricsprocessWithCuda();

	mortonIntegralsWithCuda();
	
	ParallelTreeConstructionWithCuda();

	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_P, gSimplificationParameters.clCount * sizeof(uint2)));
	CUDAErrorCheck(cudaMemset(gSimplificationParameters.dev_P, 0x0, gSimplificationParameters.clCount * sizeof(uint2)));

	CUDAErrorCheck(cudaMalloc((void**)&gSimplificationParameters.dev_PToVPrime, gSimplificationParameters.clCount * sizeof(uint)));
	CUDAErrorCheck(cudaMemset(gSimplificationParameters.dev_PToVPrime, 0x0, gSimplificationParameters.clCount * sizeof(uint)));

	AdaptiveSamplingAndTriangleMarking();

	printf("\n===============================================================\n triangle Count %d to %d \n===============================================================\n\n", faces.size(), gBVHParameters.primitiveCount);

	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_primitives, gBVHParameters.primitiveCount * sizeof(GPUFace)));
	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_Vertices, gBVHParameters.vertexCount * sizeof(Vertex)));

	Remeshing();

	gSimplificationParameters.cleanUp();

	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_MortonCodes, gBVHParameters.primitiveCount * sizeof(uint)));
	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_primitiveCenters, gBVHParameters.primitiveCount * sizeof(Vertex)));
	

	CreatePrimitiveMortonsByCuda(scene);

	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_ids, gBVHParameters.primitiveCount * sizeof(uint)));

	sortPrimitiveMortonCodesWithCuda();

	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_aabbs, gBVHParameters.primitiveCount * sizeof(stAABB)));
	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_leafNodes, gBVHParameters.primitiveCount * sizeof(GpuNode)));
	CUDAErrorCheck(cudaMalloc((void**)&gBVHParameters.dev_internalNodes, (gBVHParameters.primitiveCount -1) * sizeof(GpuNode)));
	generateAABBsWithCuda();

	generateHierarchyWithCuda();

	calculateBoundingBoxesWithCuda();

}


uint getGameObjectTriangles(GameObject* gameObject, std::vector<stAABB>& aabbs)
{
	PrintFunction;

	gameObject->centerPosition = make_float3(-4, 3, 0);

	GPUFace* gpufaces = new GPUFace[gBVHParameters.primitiveCount];
	Vertex* vertices = new Vertex[gBVHParameters.vertexCount];
	
	GpuNode* gpunodes = new GpuNode[gBVHParameters.primitiveCount + gBVHParameters.primitiveCount - 1 ];
	uint* prmitiveIndices = new uint[gBVHParameters.primitiveCount];
	CUDAErrorCheck(cudaMemcpy(gpunodes, gBVHParameters.dev_leafNodes, gBVHParameters.primitiveCount * sizeof(GpuNode), cudaMemcpyDeviceToHost));
	CUDAErrorCheck(cudaMemcpy(&gpunodes[gBVHParameters.primitiveCount], gBVHParameters.dev_internalNodes, (gBVHParameters.primitiveCount  - 1) * sizeof(GpuNode), cudaMemcpyDeviceToHost));

	CUDAErrorCheck(cudaMemcpy(prmitiveIndices, gBVHParameters.dev_ids, gBVHParameters.primitiveCount * sizeof(uint), cudaMemcpyDeviceToHost));

	aabbs.resize(gBVHParameters.primitiveCount);
	
	for (uint n = 0; n <  gBVHParameters.primitiveCount  ; ++n)
	{
		aabbs[n] = gpunodes[n].AABB;
	}

	CUDAErrorCheck(cudaMemcpy(gpufaces, gBVHParameters.dev_primitives, gBVHParameters.primitiveCount * sizeof(GPUFace), cudaMemcpyDeviceToHost));
	

	gameObject->faces.resize(gBVHParameters.primitiveCount);

	CUDAErrorCheck(cudaMemcpy(vertices, gBVHParameters.dev_Vertices, gBVHParameters.vertexCount * sizeof(Vertex), cudaMemcpyDeviceToHost));
		 
	copy(&vertices[0], &vertices[gBVHParameters.vertexCount], back_inserter(gameObject->attribute.vertices));

	
	//int d = 0;
	//for (auto V : gameObject->attribute.vertices)
	//{
	//	//-1.8938 - 0.340252 - 1.23747 to 1.22018 2.74642 1.17599
	//	//if(V.x > 1.22018 || V.y >  2.74642 || V.z > 1.17599)
	//		printf("%d %.9g %.9g %.9g\n", d, V.x, V.y, V.z);
	//	d++;
	//}

	



	uint primitiveSearched = 171;
	float len = -1;
	for (uint i = 0; i < gBVHParameters.primitiveCount; ++i)
	{
		gameObject->faces[i].vertexIndices[0] = gpufaces[i].vertexIndices.first;
		gameObject->faces[i].vertexIndices[1] = gpufaces[i].vertexIndices.second;
		gameObject->faces[i].vertexIndices[2] = gpufaces[i].vertexIndices.third;
		
		auto v1 = gameObject->attribute.vertices[gpufaces[i].vertexIndices.first];
		auto v2 = gameObject->attribute.vertices[gpufaces[i].vertexIndices.second];
		auto v3 = gameObject->attribute.vertices[gpufaces[i].vertexIndices.third];

	/*	float l = distance(v1, v2);
		if(  l > len)
		{
			printf("v1 v2 len %.9g i %d\n", l, i);
			len = l;
			primitiveSearched = i;
		}
		l = distance(v1, v3);
		if (l > len)
		{
			printf("v1 v3 len %.9g i %d\n", l, i);
			len = l;
			primitiveSearched = i;
		}
		l = distance(v2, v3);
		if (l > len)
		{
			printf(" v2 v3 len %.9g i %d\n", l,i);
			len = l;
			primitiveSearched = i;
		}*/

	}

	//auto v1 = gameObject->attribute.vertices[gpufaces[primitiveSearched].vertexIndices.first];
	//auto v2 = gameObject->attribute.vertices[gpufaces[primitiveSearched].vertexIndices.second];
	//auto v3 = gameObject->attribute.vertices[gpufaces[primitiveSearched].vertexIndices.third];

	//printf("primitiveSearched %d\n", primitiveSearched);
	//
	//printf("%d %d %d\n",  gpufaces[primitiveSearched].vertexIndices.first, gpufaces[primitiveSearched].vertexIndices.second, gpufaces[primitiveSearched].vertexIndices.third);

	//auto V = gameObject->attribute.vertices[gpufaces[primitiveSearched].vertexIndices.first];
	//printf("%d %.9g %.9g %.9g\n", gpufaces[primitiveSearched].vertexIndices.first, V.x, V.y, V.z);

	//V = gameObject->attribute.vertices[gpufaces[primitiveSearched].vertexIndices.second];
	//printf("%d %.9g %.9g %.9g\n", gpufaces[primitiveSearched].vertexIndices.second, V.x, V.y, V.z);

	//V = gameObject->attribute.vertices[gpufaces[primitiveSearched].vertexIndices.third];
	//printf("%d %.9g %.9g %.9g\n", gpufaces[primitiveSearched].vertexIndices.third, V.x, V.y, V.z);


	//printf("lengths: %.9g %.9g %.9g\n", distance(v1, v2), distance(v1, v3), distance(v2, v3));

	delete[]  vertices;
	delete[] gpufaces;



	//gameObject->attribute.vertices[363] = make_float3(0.0, - 0.0, - 0.0);

	return 0;
}